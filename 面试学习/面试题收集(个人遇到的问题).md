# 									面试问题收集处

## Java基础：

#### 	1.Java 中浅拷贝和深拷贝的区别，以及实现方式    (https://www.cnblogs.com/shakinghead/p/7651502.html)

​	浅拷贝：对于基本数据类型，会直接进行值传递，也就是将该数据复制一份给新的对象。这时两份数据分属不同的地址，两者互不影响。而对于引用数据类型的变量(对象)，那么浅拷贝则进行引用传递，也就是两者指向同一个内存地址。在这种情况下，修改任何一个对象的属性将会影响到另一个对象

​	

​	深拷贝：相当于开辟新的内存地址，创建了一个相同属性、方法的对象，但地址不同，两者之间没有实际关联。





浅拷贝的实现方式：

​	(1)  通过拷贝构造方法实现浅拷贝：拷贝构造方法指的是该类的构造方法参数为该类的对象。使用拷贝构造方法可以很好地完成浅拷贝，直接通过一个现有的对象创建出与该对象属性相同的新的对象

```java
//拷贝构造方法
    public Person(Person p) {
        this.name=p.name;
        this.age=p.age;
    }
```

​	(2) 重写 clone() 方法进行浅拷贝： Object类中有一个 colne方法，但使用该方法需要实现Cloneable接口，否则会抛出异常CloneNotSupportedException

​	解决方法是，在要使用clone方法的类中重写clone()方法，通过super.clone()调用Object类中的原clone方法。

```java
 //重写Object类的clone方法
    public Object clone() {
        Object obj=null;
        //调用Object类的clone方法，返回一个Object实例
        try {
            obj= super.clone();
        } catch (CloneNotSupportedException e) {
            e.printStackTrace();
        }
        return obj;
    }
```



深拷贝的实现方式：

​	（1） 重写clone() 方法 实现Cloneable接口。

​		(2)  通过序列化 实现深拷贝：将对象序列化为字节序列后，默认会将该对象的整个对象图进行序列化，再通过反序列即可完美地实现深拷贝。

```java
//通过序列化方法实现深拷贝	
		ByteArrayOutputStream bos=new ByteArrayOutputStream();
        ObjectOutputStream oos=new ObjectOutputStream(bos);
        oos.writeObject(target);   //target为需要序列化的对象
        oos.flush();
        ObjectInputStream ois=new ObjectInputStream(new ByteArrayInputStream(bos.toByteArray()));
        Student stu2=(Student)ois.readObject();
```



需要注意的一个点：如果某个属性被**transient** 关键字所修饰，那么就无法序列化从而进行拷贝了 (transient的作用：使修饰的属性的生命周期仅存于调用者的内存中而不会写到磁盘里持久化。)

------



#### 2.( IO流 )序列化了解过吗？说说实现方式   （https://www.cnblogs.com/9dragon/p/10901448.html）

​	序列化：将对象写入IO流中（ 另一种说法是：把 Java对象转换为字节序列的过程 ）

​	反序列化：从IO流中恢复对象 （ 另一种说法是：把字节序列恢复为 JAVA对象的过程 ）



背景：**为什么要有序列化以及什么是序列化？**——在系统下次启动后，某对象需要恢复到上次的状态时，这时需要考虑“**持久化**”该对象。   而持久化则会想到数据库或者缓存。除此之外，若以**注重面向对象的思维**来持久化对象，也就是**基于对象能够在程序不运行的情况下仍能存在并保存其信息的需求**，故对象的序列化功能从而诞生。（简单理解：对象不只是存储于**内存**中，它还需要在传输网络中进行传输，并且保存起来后反序列化进行恢复）

**什么是序列化**？——把**对象转换成一串由二进制字节组成的数组**，然后将这二进制数据保存在磁盘或传输网络(  熟悉的 IO 流操作 )



**意义：序列化机制允许将实现序列化的Java对象转换位字节序列，这些字节序列可以保存在磁盘上，或通过网络传输，以达到以后恢复成原来的对象。序列化机制使得对象可以脱离程序的运行而独立存在。**

使用场景：所有可在网络上传输的对象都必须是可序列化的。比如RMI（remote method invoke,即**远程方法调用**），传入的参数或返回的对象都是可序列化的，否则会出错；**所有需要保存到磁盘的java对象都必须是可序列化的。通常建议：程序创建的每个JavaBean类都实现Serializeable接口。**



**序列化版本号的作用**：java 序列化提供了一个 **private static final long serialVersionUID** 的序列化版本号，只有版本号相同才能进行反序列化。如果反序列化使用的**class的版本号**与序列化时使用的**不一致**，反序列化会报**InvalidClassException异常。**

**序列化版本号可自由指定，如果不指定，JVM会根据类信息自己计算一个版本号，这样随着class的升级，就无法正确反序列化；不指定版本号另一个明显隐患是，不利于jvm间的移植，可能class文件没有更改，但不同jvm可能计算的规则不一样，这样也会导致无法反序列化。**



序列化的**实现方式**： 需要将某个对象保存到磁盘上或者通过网络传输，那么该对象需要**实现Serializable接口或者Externalizable接口**。

​	①实现Serializable接口。Serializable接口是一个标记接口，不用实现任何方法，一旦实现该接口，该类的对象就是可序列化的。且会有一个序列化的版本号，**用来区分我们所编写的类的版本**，用于反序列化时确定版本。

​	**序列化步骤：**

​				步骤一：创建一个**ObjectOutputStream** 输出流。

​				步骤二：调用ObjectOutputStream对象的**writeObject**输入可序列化对象。

​	

​	反序列化步骤：

​				步骤一：创建一个ObjectInputStream输入流。

​				步骤二：调用ObjectInputStream对象的readObject()输出反序列化对象。

​	

② 实现 **Externalizable** 接口：强制自定义序列化。通过实现Externalizable接口，必须实现writeExternal、readExternal方法。

需要注意 **Externalizable接口不同于Serializable接口，实现此接口必须实现接口中的两个方法实现自定义序列化，这是强制性的；特别之处是必须提供pulic的无参构造器，因为在反序列化的时候需要反射创建对象**。



注意点：① **反序列化并不会调用构造方法。反序列的对象是由JVM自己生成的对象，不通过构造方法生成。**

​				② **成员是引用的序列化**。这里指：一个可序列化的类，当其成员变量既不是基本类型、也不是String类型，那么这个**成员变量**（既不是基本类型，也不是String类型，那么就只能是引用类型了）必须是**可序列化的**。

​				③  **同一对象序列化多次的机制**：序列化同一对象，并不会将此对象序列化多次得到多个对象。

​					序列化算法：(1) 所有保存到磁盘上的对象都有一个**序列化编码号**。

​											(2) 当程序试图序列化一个对象时，会先检查此对象是否已序列化过，只有此对象从未在虚拟机中被序列化过，才会将此对象序列化为字											节序列输出。

​											(3) 如果此对象已经序列化过，直接输出序列化编号即可。

​					**序列化算法存在的问题**：由上述可知，**同一个对象不会被重复序列化**。这样如果**已序列化对象的内容被更改后**，**再次序列化，并不会再次将此对象转换为字节序列，而只是保存序列化编号。**

​				④ **可选的自定义序列化**：可以使用关键字 **transient** 来选择不需要序列化的字段。或通过重写 writeObject() 和 readObject() 来选择哪些需要序列化的字段。

​				

```java
 
import java.io.*;

public class Person implements Serializable {
    private String name;
    private int age;
    //我不提供无参构造器
    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    @Override
    public String toString() {
        return "Person{" +
                "name='" + name + '\'' +
                ", age=" + age +
                '}';
    }
}

//序列化将对象转换成一串由二进制字节组成的数组并写入文件中，在文件中看到的是一串乱码，这是二进制输出无需担心。在反序列化能得到理想结果即可
 class WriteObject {
    public static void main(String[] args) {
        try (//创建一个ObjectOutputStream输出流
             ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("D:\\object.txt"))) {
            //将对象序列化到文件s
            Person person = new Person("9龙", 23);
            oos.writeObject(person);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

//反序列化，将文件中的二进制字节数组转换成对象并赋予，输出时和 序列化时输入的对象属性等相同
  class ReadObject {
    public static void main(String[] args) {
        try (//创建一个ObjectInputStream输入流
             ObjectInputStream ois = new ObjectInputStream(new FileInputStream("D:\\object.txt"))) {
            Person brady = (Person) ois.readObject();
            System.out.println(brady);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

```



**序列化的过程**(  **重要**)：**递归写入**的过程。

![](C:\Users\AWU\Desktop\面试学习\面试题整理图片存储池\序列化原理过程.png)

**总结**：①所有需要网络传输的对象都需要实现序列化接口，通过建议所有的javaBean都实现Serializable接口

​			②对象的类名、实例变量（包括基本类型，数组，对其他对象的引用）都会被序列化；方法、类变量、transient实例变量都不会被序列化

​			③如果想让某个变量不被序列化，使用transient修饰

​			④序列化对象的引用类型成员变量，也必须是可序列化的，否则，会报错

​			⑤反序列化时必须有序列化对象的class文件

​			⑥当通过文件、网络来读取序列化后的对象时，必须按照实际写入的顺序读取

​			⑦单例类序列化，需要重写readResolve()方法；否则会破坏单例原则

​			⑧同一对象序列化多次，只有第一次序列化为二进制流，以后都只是保存序列化编号，不会重复序列化

​			⑨建议所有可序列化的类加上serialVersionUID 版本号，方便项目升级



#### 3.(集合类) 说一下HashMap





#### 



#### 

#### 

#### 





#### 











####  

------

## 计算机网络：

#### 	1.计算机网络内容：TCP三次握手的概念，为什么不能两次握手？ (按书中的知识讲的，但面试官觉得繁琐，说一句话"根据初始序列号"什么就行了)

#### 

#### 	2.（笔试） TCP三次握手以及TCP四次挥手













------

## JUC（多线程与并发）：

#### 	1.线程池的概念(https://blog.csdn.net/qq_44750696/article/details/104640143)

​	**什么是线程池？**——一系列线程的集合，称为线程池。

​	**使用线程池有什么好处呢**？——① 降低资源消耗。通过重复利用已创建的线程，来避免了线程的创建和销毁所造成的资源消耗。

​														  ② 提高响应速度。使用已创建的线程，可以立即执行任务。

​														  ③ 提高线程的可管理性。如果无限制地创建线程，在高并发情况下，不仅会消耗系统资源，还会降低系统稳定性。使用线程池可以对多个线程请求进行 **统一分配、调优和监控**。提高了对线程的可管理性。

​	

​	**线程池的工作机制？**—— 在线程池的编程模式下，系统将任务传给线程池，让线程池根据当前**核心线程数、阻塞队列、最大线程数是否已满**，逐级向下查找，若都已满则实行 **拒绝策略**。且线程池中，仍旧是一个线程只能执行一个任务，但是可以向线程池提交多个任务来实现多线程。

​	

​	**那么有哪些线程池呢？**——  首先，可以通过 **java.util.concurrent包下的 Executors 类** 提供一系列**静态工厂方法**，进行各种**线程池的创建**。

​			常用的方法如下：

```java
public static ExecutorService newFixedThreadPool()
public static ExecutorService newSingleThreadExecutor()
public static ExecutorService newCachedThreadPool()
public static ScheduledExecutorService newSingleThreadScheduledExecutor()
public static ScheduledExecutorService newScheduledThreadPool()
    1、newFixedThreadPool：固定数量的线程池，该方法返回一个 可重用的、`固定线程数量`的线程池；

　　2、newSingleThreadExecutor：单线程的线程池，它只会用`唯一的线程`来执行任务，保证所有任务按照`指定顺序(FIFO(先进先出),  LIFO(后进先出),  优先级)`执行；

　　3、newCachedThreadPool：`可缓存线程池`，该线程池可以根据实际情况`调整池子中的线程数量`，当执行当前任务时，上一个任务已经完成，会复用执行上一个任务的线程，而不用每次新建线程，如果上一个线程没有结束才会新建线程，可缓存型池子通常用于执行一些生存期较短的任务；

　　4、newScheduledThreadPool：`可定时线程池`，该线程池可以设定线程的执行时间，可以用来去执行一些`定时及周期性`的任务。

```

通过上述，再深入了解一些。

```java
public static ExecutorService newFixedThreadPool(int nThreads) {
        return new ThreadPoolExecutor(nThreads, nThreads,
                                      0L, TimeUnit.MILLISECONDS,
                                      new LinkedBlockingQueue<Runnable>());
    }
```

通过代码可以看到，该静态工厂方法在创建线程池时，实质上调用的是 **ThreadPoolExecutor** **类**来进行线程池的创建。									



​	那么**线程池是如何实现线程复用的**呢？—— 首先，需要了解线程的实现方式：①通过extends**继承Thread类**，并**重写run()**方法。  ②通过 implement **实现 Callable或Runnable 接口，并重写run()** 方法。



​																		



#### 	2.线程安全下的单例模式？(https://blog.csdn.net/cselmu9/article/details/51366946)

​	首先，需要了解什么是单例模式？——《Head First 设计模式》一书中，对单例模式的简要定义为：确保一个类只有一个实例，并提供一个全局访问点。



那么，单例模式有**哪些实现方式呢**？

① **饿汉式单例模式**——使用static关键字静态初始化时创建单例对象。在调用方法时使用此创建好了的单例对象即可。

```java
public class MySingleton {
	
	private static MySingleton instance = new MySingleton();  //在静态初始化时创建该单例对象
	
	private MySingleton(){}
	
	public static MySingleton getInstance() {
		return instance;
	}
	
}
```

② 懒汉式单例模式——在调用方法时获取实例对象时才创建单例对象。但该操作在多线程并发下，无法保证单例对象是否唯一。

```java

public class MySingleton {
	
	private static MySingleton instance = null;
	
	private MySingleton(){}
	
	public static MySingleton getInstance() {
		if(instance == null){//懒汉式
			instance = new MySingleton();
		}
		return instance;
	}
}

```

③线程安全的懒汉式单例模式( 方法中声明synchronized关键字、同步代码块实现、 针对某些重要的代码来进行单独的同步（可能非线程安全） )

​		(1) 方法中声明synchronized关键字：出现线程非安全问题，这是由于多个线程进入getInstance()方法，故对此方法进行sychronized 的锁同步机制。但该方法的运行效率会很低。

```java
public class MySingleton {
	
	private static MySingleton instance = null;
	
	private MySingleton(){}
	
	public synchronized static MySingleton getInstance() {
		try { 
			if(instance != null){//懒汉式 
				
			}else{
				//创建实例之前可能会有一些准备性的耗时工作 
				Thread.sleep(300);
				instance = new MySingleton();
			}
		} catch (InterruptedException e) { 
			e.printStackTrace();
		}
		return instance;
	}
} 
```

​	(2)  同步代码块实现：这样将会锁住MySingleton整个类，同样的效率也很低下。	

```java
public class MySingleton {
	
	private static MySingleton instance = null;
	
	private MySingleton(){}
	
	//public synchronized static MySingleton getInstance() {
	public static MySingleton getInstance() {
		try { 
			synchronized (MySingleton.class) {
				if(instance != null){//懒汉式 
					
				}else{
					//创建实例之前可能会有一些准备性的耗时工作 
					Thread.sleep(300);
					instance = new MySingleton();
				}
			}
		} catch (InterruptedException e) { 
			e.printStackTrace();
		}
		return instance;
	}
} 
```

​	(3) 针对某些重要的代码来进行单独的同步（可能非线程安全）: 针对某些重要的代码进行单独的同步，而不是全部进行同步，可以极大的提高执行效率

```java
public class MySingleton {
	
	private static MySingleton instance = null;
	
	private MySingleton(){}
	 
	public static MySingleton getInstance() {
		try {  
			if(instance != null){//懒汉式 
				
			}else{
				//创建实例之前可能会有一些准备性的耗时工作 
				Thread.sleep(300);
				synchronized (MySingleton.class) {
					instance = new MySingleton();
				}
			} 
		} catch (InterruptedException e) { 
			e.printStackTrace();
		}
		return instance;
	}
}
```



④ **双检查锁机制**：首先检查是否实例已经创建了，如果尚未创建，才进行同步。这样一来只有第一次会同步。

注意：在1.4及更早版本的Java中，许多 JVM 对于volatile关键字的实现会导致双重检查加锁的失效。

**且使用volatile关键字保其可见性、禁止指令重排的作用, 保证先初始化, 再把对象引用赋值给instance变量.** 

```java
public class MySingleton {
	
	//使用volatile关键字保其可见性、禁止指令重排的作用, 保证先初始化, 再把对象引用赋值给instance变量. 
	volatile private static MySingleton instance = null;
	
	private MySingleton(){}
	 
	public static MySingleton getInstance() {
		try {  
			if(instance != null){//懒汉式 
				
			}else{
				//创建实例之前可能会有一些准备性的耗时工作 
				//Thread.sleep(300);
				synchronized (MySingleton.class) {
					if(instance == null){//二次检查
						instance = new MySingleton();
					}
				}
			} 
		} catch (InterruptedException e) { 
			e.printStackTrace();
		}
		return instance;
	}
} 
```



#### 3.高并发和多线程的关系和区别?

首先，需要了解**高并发和多线程的定义**。

所谓**高并发，是一种系统运行过程中遇到的一种“短时间内遇到大量操作请求”的情况，主要发生在web系统集中大量访问收到大量请求**（例如：12306的抢票情况；天猫双十一活动）。该情况的发生会导致系统在这段时间内执行大量操作，例如对资源的请求、数据库的操作等（定义）

高并发相关**常用的一些指标有：响应时间、吞吐量、每秒查询率QPS、并发用户数**

而多线程，指的是一个进程中可以有多个执行路径。







------

## JVM:

#### 	1.垃圾收集器的概念，判定垃圾对象的方法？有哪些垃圾收集器以及实现过程？

















------

## 数据结构与算法：

#### 	1.有哪些排序算法不稳定以及稳定的？











------



## Redis分布式缓存数据库：

#### 1.Redis的数据存储格式？

​	答：redis自身是一个Map映射结构，其中所有数据都是采用 key:value (键值对) 的形式存储。

​			Redis的数据类型指的是存储的数据的类型，也就是 value 部分的类型，**key 部分永远都是字符串**







#### 	2.什么是跳表了解吗？





#### 	3.有关Redis的五大数据类型？缓存击穿、缓存穿透、缓存雪崩的概念以及防治措施

答：string 字符串（可以为整形、浮点型和字符串，统称为元素）
list 列表（实现队列,元素不唯一，先入先出原则）
set 集合（各不相同的元素）
hash hash散列值（hash的key必须是唯一的） hash类型下的value只能存储字符串，不允许存储其他类型数据，不存在嵌套现象。如果数据未获取到，对应的值为nil
sort set 有序集合



应用场景方面：

​	①String类型的应用场景：微信投票，每个微信号每4个小时只能投1票。电商商家开启热门商品推荐。新闻网站出现热点新闻。B站、微博、抖音等显示粉丝数和视频、微博等数量(这些是热点数据，在不断变化) 

​			 如何实现这些应用场景呢？—— 解决思路是：给用户设置一个唯一的id，并为其设置一个有效时长，当时间已经超过设定时间后将id删除。 这是利用了**setex**命令来实现 数据的**时效性（控制数据的生命周期，实现热点数据）**。而对于粉丝数和视频数这类的，可以通过 在Redis中为用户设定用户信息，以用户主键和属性值作为key，后台设定时间定时刷新数据即可。

​	②hash类型应用场景：购物车





------



## MYSQL:

### 	1.sql语句的执行顺序了解吗？  （https://blog.csdn.net/u014044812/article/details/51004754）

​			① from  ② join   ③ on   ④ where  ⑤ group by  ⑥ avg,sum...  ⑦  having  ⑧ select  ⑨ distinct  ⑩ order by  11.limit

​		具体流程：

```
第一步：首先对from子句中的前两个表执行一个笛卡尔乘积，此时生成虚拟表 vt1（选择相对小的表做基础表）。 
第二步：接下来便是应用on筛选器，on 中的逻辑表达式将应用到 vt1 中的各个行，筛选出满足on逻辑表达式的行，生成虚拟表 vt2 。
第三步：如果是outer join 那么这一步就将添加外部行，left outer jion 就把左表在第二步中过滤的添加进来，如果是right outer join 那么就将右表在第二步中过滤掉的行添加进来，这样生成虚拟表 vt3 。

第四步：如果 from 子句中的表数目多余两个表，那么就将vt3和第三个表连接从而计算笛卡尔乘积，生成虚拟表，该过程就是一个重复1-3的步骤，最终得到一个新的虚拟表 vt3。 
第五步：应用where筛选器，对上一步生产的虚拟表引用where筛选器，生成虚拟表vt4，在这有个比较重要的细节不得不说一下，对于包含outer join子句的查询，就有一个让人感到困惑的问题，到底在on筛选器还是用where筛选器指定逻辑表达式呢？on和where的最大区别在于，如果在on应用逻辑表达式那么在第三步outer join中还可以把移除的行再次添加回来，而where的移除的最终的。举个简单的例子，有一个学生表（班级,姓名）和一个成绩表(姓名,成绩)，我现在需要返回一个x班级的全体同学的成绩，但是这个班级有几个学生缺考，也就是说在成绩表中没有记录。为了得到我们预期的结果我们就需要在on子句指定学生和成绩表的关系（学生.姓名=成绩.姓名）那么我们是否发现在执行第二步的时候，对于没有参加考试的学生记录就不会出现在vt2中，因为他们被on的逻辑表达式过滤掉了,但是我们用left outer join就可以把左表（学生）中没有参加考试的学生找回来，因为我们想返回的是x班级的所有学生，如果在on中应用学生.班级='x'的话，left outer join会把x班级的所有学生记录找回（感谢网友康钦谋__康钦苗的指正），所以只能在where筛选器中应用学生.班级='x' 因为它的过滤是最终的。 

第六步：group by 子句将中的唯一的值组合成为一组，得到虚拟表vt5。如果应用了group by，那么后面的所有步骤都只能得到的vt5的列或者是聚合函数（count、sum、avg等）。原因在于最终的结果集中只为每个组包含一行。这一点请牢记。 

第七步：应用cube或者rollup选项，为vt5生成超组，生成vt6. 
第八步：应用having筛选器，生成vt7。having筛选器是第一个也是为唯一一个应用到已分组数据的筛选器。 
第九步：处理select子句。将vt7中的在select中出现的列筛选出来。生成vt8. 

第十步：应用distinct子句，vt8中移除相同的行，生成vt9。事实上如果应用了group by子句那么distinct是多余的，原因同样在于，分组的时候是将列中唯一的值分成一组，同时只为每一组返回一行记录，那么所以的记录都将是不相同的。 

第十一步：应用order by子句。按照order_by_condition排序vt9，此时返回的一个游标，而不是虚拟表。sql是基于集合的理论的，集合不会预先对他的行排序，它只是成员的逻辑集合，成员的顺序是无关紧要的。对表进行排序的查询可以返回一个对象，这个对象包含特定的物理顺序的逻辑组织。这个对象就叫游标。正因为返回值是游标，那么使用order by 子句查询不能应用于表表达式。排序是很需要成本的，除非你必须要排序，否则最好不要指定order by，最后，在这一步中是第一个也是唯一一个可以使用select列表中别名的步骤。 

第十二步：应用top选项。此时才返回结果给请求者即用户。 
 
```











##  





------



## 情景实践：

### 	1.如何实现一个高并发高可用系统：https://blog.csdn.net/u014352080/article/details/81487303

​		首先，需要知道什么是高并发和高可用：

​		**高并发（High Concurrency）是一种系统运行过程中遇到的一种“短时间内遇到大量操作请求”的情况，主要发生在web系统集中大量访问收到大量请求（例如：12306的抢票情况；天猫双十一活动）。该情况的发生会导致系统在这段时间内执行大量操作，例如对资源的请求，数据库的操作**等。

高并发相关常用的**处理指标**有：

​	1.**响应时间**(Response Time): 系统对请求做出的响应时间。

​	2.**吞吐量**(Throughput) ：单位时间内处理请求的数量。

​	3.**每秒查询率QPS**( Query Per Second ): QPS：每秒响应请求数。

​	4.**并发用户数**：同时承载正常使用系统功能的用户数量。



​	高可用HA（High Availability）是分布式系统架构设计中必须考虑的因素之一，它通常是指，通过**设计减少系统不能提供服务的时间**。

那么要**如何保障高并发和高可用呢**？ 

​	首先，互联网分布式架构设计，提供系统**并发能力**的方式理论上有两种：**垂直扩展和水平扩展**  (这里是指保障系统的高并发)

垂直扩展：指的是**提高单机处理能力**。垂直扩展的方式有两种——

​		(1) 增强**单机硬件性能**。例如：增加CPU核数如32核，升级更好的网卡如万兆，升级更好的硬盘如SSD，扩充硬盘容量如2T，扩充系统内存如128G；

​		(2) 提升**单机架构性能**，例如：使用Cache来减少IO次数，使用异步来增加单服务吞吐量，使用无锁数据结构来减少响应时间；

由于一台机器的单机性能始终会有极限，所以**互联网分布式架构设计高并发的解决方案实际上**还是要**通过水平扩展解决**。

水平扩展：指的是**增加服务器数量，线性扩充系统性能**。  (水平扩展对系统架构设计是有要求的，如何在架构各层进行可水平扩展的设计，以及互联网公司架构各层常见的水平扩展实践)



其次，如何保障高可用？   —— 在系统设计的过程中避免单点( 单点是系统高可用的大敌 ，什么是单点呢)，理论上说，高可用保证的原则是 **集群化**，或者叫 **冗余**，即 只有一个单点服务，挂了服务会受影响，如果有冗余备份，挂了还会有其他备用节点顶上。

但有了集群化(冗余)还不够，例如出现网络延迟而导致的服务假性宕机(实际上是因为网络延迟导致)，这时可能出现两台主机，所以还**需要通过 “自动故障转移” + “冗余”来实现系统的高可用**。



那么，了解了高并发和高可用，回到问题上。该如何设计呢？

分为以下八点：

1.系统拆分

2.Cache(缓存)

3.MQ

4.数据库拆分(分库分表)

5.读写分离( 集群 )

6.ElasticSearch

7.HTML 页面静态化

8.CDN加速



每个点来详细了解一下，首先是

①**系统拆分**，指的是将系统拆分成多个子系统，这里可以 通过  基于Springboot实现多个微服务系统的Springcloud。并且每个微服务单独连自己的数据库(除却金额、个人信息等可在各个微服务间共享的数据)。

②**缓存**，常见的一种优化方式，比较常用的缓存数据库是**Redis**。在数据库层上加一层缓存，减少对数据库的访问压力。**缓存中的数据都是存储在内存里的，而数据库中的数据是写在磁盘上的，访问内存肯定是比访问磁盘快的可不止一个数量级**。

③**MQ**，一类消息中间件。如RabbitMQ、ActiveMQ、Kafka、RocketMQ等。这里采用MQ主要处理的是**高并发写的场景**。应**考虑承载复杂的写业务逻辑的场景中，如何使用MQ来异步写，提高并发性**。

④**分库分表**，指的是 在表中数据量大的时候，数据查询等操作会变得缓慢，数据库拆分就会成为一个紧急的需求。分库分表的实现有两种方式：**第一种是垂直拆分，第二种是水平拆分**。

**水平拆分是把同一个表的数据按一定规则拆到不同的数据库中，每个库可以放在不同的服务器上**

**垂直切分**是指按照业务将表进行分类，分布到不同的数据库上面，这样也就将数据或者说压力分担到不同的库上面



⑤**读写分离**，考虑到大多数情况下读多写少，可以采用 主从模式，主机写入、从机读取。

⑥ **ElasticSearch**，简称es。es是分布式的，可以随便扩容，一些**比较简单的查询、统计类的操作**，可以考虑用 es 来承载，还有一些**全文搜索**类的操作，也可以考虑用 es 来承载。

⑦ **CDN加速**，任何一个互联网系统面向的用户都遍布于地球的每个角落，每个角落的请求到机房可用多种路径可选，正所谓条条大路通罗马，这里是条条路径通机房。其中有速度快的路径有慢的路径，如何选择最优路径，把每个角落的请求快速的传递到机房，这就是 CDN 的功能

⑧ **HTML页面静态化**，**最常见的优化方式，成本低不需要考虑硬件成本**。静态页面部署在 NGNIX 中，收到用户请求，Ngnix 不需要访问 Webapp 即可响应用户，减少应用渲染页面的时间，同时也降低了应用的压力













