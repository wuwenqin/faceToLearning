# 													索引

# 







## 1.**B 树& B+树两者有何异同呢？**

 	1）B 树的所有节点既存放键(key) 也存放 数据(data)，而 B+树只有叶子节点存放 key 和 data，其他内节点只存放 key。
 	
 	2） B 树的叶子节点都是独立的;B+树的叶子节点有一条引用链指向与它相邻的叶子节点

​	 3）B 树的检索的过程相当于对范围内的每个节点的关键字做二分查找，可能还没有到达叶子节点，检索就结束了。而 B+树的检索效率就很稳定了，任何查找都是从根节点到叶子节点的过程，叶子节点的顺序检索很明显





## 2.MyISAM 引擎和 InnoDB 引擎都是使用 B+Tree 作为索引结构 ，说说两者的实现方式

​	MyISAM 引擎中，B+Tree 叶节点的 **data 域存放的是数据记录的地址**。在索引检索的时候，首先按照 B+Tree 搜索算法搜索索引，如果指定的 Key 存在，则取出其 data 域的值，然后以 **data 域的值为地址读取相应的数据记录**。这被称为“**非聚簇索引**”。

InnoDB 引擎中，其**数据文件本身就是索引文件**。相比 MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按 B+Tree 组织的一个索引结构，树的叶节点 data 域保存了完整的数据记录。这个索引的 key 是数据表的主键，因此 InnoDB 表数据文件本身就是主索引。这被称为“**聚簇索引**（或聚集索引）”，而其余的索引都作为辅助索引，**辅助索引的 data 域存储相应记录主键的值而不是地址**，这也是和 MyISAM 不同的地方。在根据主索引搜索时，直接**找到 key 所在的节点即可取出数据**；在**根据辅助索引查找时，则需要先取出主键的值，在走一遍主索引**。 因此，在设计表的时候，**不建议使用过长的字段作为主键**，也不建议使用非单调的字段作为主键，这样会造成主索引频繁分裂。



------



## 3.聚簇索引与非聚簇索引（也叫二级索引）

- 聚簇索引：将数据存储与索引放到了一块，找到索引也就找到了数据
- 非聚簇索引：将数据存储于索引分开结构，索引结构的叶子节点指向了数据的对应行，myisam通过key_buffer把索引先缓存到内存中，当需要访问数据时（通过索引访问数据），在内存中直接搜索索引，然后通过索引找到磁盘相应数据，这也就是为什么索引不在key buffer命中时，速度慢的原因



**一个概念**：innodb中，在聚簇索引之上创建的索引称之为辅助索引，辅助索引访问数据总是需要二次查找，非聚簇索引都是辅助索引，像复合索引、前缀索引、唯一索引，辅助索引叶子节点存储的不再是行的物理位置，而是主键值。



**聚簇索引具有唯一性**

由于聚簇索引是将数据跟索引结构放到一块，因此一个表仅有一个聚簇索引



## **一个误区：把主键自动设为聚簇索引**

**聚簇索引默认是主键**，如果表中没有定义主键，InnoDB 会选择一个**唯一的非空索引**代替。如果没有这样的索引，InnoDB 会**隐式定义一个主键**来作为聚簇索引。InnoDB 只聚集在同一个页面中的记录。包含相邻键值的页面可能相距甚远。**如果你已经设置了主键为聚簇索引，必须先删除主键，然后添加我们想要的聚簇索引，最后恢复设置主键即可**。

![数据库索引](C:\Users\AWU\Desktop\面试学习\数据库索引.jpeg)





## 4.**聚簇索引的优势**

看上去聚簇索引的效率明显要低于非聚簇索引，因为**每次使用辅助索引检索都要经过两次B+树查找**，这不是多此一举吗？聚簇索引的优势在哪？

1. 由于**行数据和叶子节点存储在一起，同一页中会有多条行数据，访问同一数据页不同行记录时，已经把页加载到了Buffer中，再次访问的时候，会在内存中完成访问**，不必访问磁盘。这样**主键和行数据是一起被载入内存的，找到叶子节点就可以立刻将行数据返回**了，**如果按照主键Id来组织数据，获得数据更快**。
2. **辅助索引使用主键作为"指针"而不是使用地址值作为指针的好处**是，**减少了当出现行移动或者数据页分裂时辅助索引的维护工作**，**使用主键值当作指针会让辅助索引占用更多的空间，换来的好处是InnoDB在移动行时无须更新辅助索引中的这个"指针"**。**也就是说行的位置（实现中通过16K的Page来定位）会随着**[**数据库**](https://cloud.tencent.com/solution/database?from=10680)**里数据的修改而发生变化（前面的B+树节点分裂以及Page的分裂），使用聚簇索引就可以保证不管这个主键B+树的节点如何变化，辅助索引树都不受影响**。
3. 聚簇索引适合用在排序的场合，非聚簇索引不适合
4. 取出一定范围数据的时候，使用用聚簇索引
5. 二级索引需要两次索引查找，而不是一次才能取到数据，因为存储引擎第一次需要通过二级索引找到索引的叶子节点，从而找到数据的主键，然后在聚簇索引中用主键再次查找索引，再找到数据
6. 可以把**相关数据保存在一起**。例如实现电子邮箱时，可以根据用户 ID 来聚集数据，这样只需要从磁盘读取少数的数据页就能获取某个用户的全部邮件。如果没有使用聚簇索引，则每封邮件都可能导致一次磁盘 I/O。





# 5.最左前缀原则

在MySQL建立**联合索引**时会遵守**最左前缀匹配原则****，即**最左优先**，在检索数据时从联合索引的最左边开始匹配。





# 6.MyISAM和InnoDB在CRUD下会默认加哪些锁？

- MyISAM在读时加表读锁，在增删改时加表写锁
- InnoDB在读时不加锁，在增删改时加排它锁（X）







# 7. InnoDB三种行锁的算法

Record Lock：单个行记录上的锁

Gap Lock: 间隙锁，锁定一个范围，但不包括记录本身

Next-Key Lock:锁定一个范围，并且包括记录本身



例如一个索引有9,11,13,20这4个值，那么该索引可能被Next-Key Locking的范围为（**左开右闭** ）：

(- &，9]
(9,11]
(13,20]
(20,+ &)



InnoDB存储引擎**默认的事务隔离级别是REPEATABLE READ**,在该隔离级别下,
其采用**Next-Key Locking的方式来加锁**。

**采用Next-Key Lock的锁定技术称为Next-Key Locking。这种设计的目的是为了解决幻读（Phantom Problem）。利用这种锁定技术，锁定的不是单个值，而是一个范围。**



**Gap Lock的作用是为了阻止多个事务将记录插入到同一个范围内，而这会导致Phantom Problem(幻象)问题的产生。**







# 8.Mysql架构及其各个部分概述



 ![o_201016234328mysql架构](C:\Users\AWU\Desktop\面试学习\o_201016234328mysql架构.png)



- 连接器：负责用户登录数据库，校验身份、校验权限。如果账户名和密码都正确，连接器就会到权限表中查询这个用户的所有权限。之后这个连接里的所有需要判断权限的情况都依赖于此时读到的权限数据。也就是说只要连接不断开，就算此时管理员修改了该用户的权限，也是不受影响的，还是按照之前查询到的权限来判断。
- 查询缓存：连接建立后，执行查询语句时要先查询缓存。如果缓存中存在这个key，就直接返回给客户端。没有这个key，执行后续的操作，最后会把结果缓存起来。真正执行缓存查询的时候会先校验用户的权限。MySQL8.0之后删除了缓存的功能。
- 分析器：如果没有命中缓存，就进入分析器，分析SQL语句究竟想干嘛，具体分为两步
  - 词法分析：提取出关键字，如select、表名、字段名、查询条件等
  - 语法分析：判断sql语句的语法是否正确
- 优化器：确定执行的较优方案，比如多个索引的时候如何选择索引，多表查询的时候如何选择关联顺序
- 执行器：准备执行sql，执行前会先校验用户权限，没有权限返回错误信息。有权限就去调用引擎接口，返回引擎接口的结果。





# 9.redolog和binlog是什么？他们的区别？

 ![o_201016234945mysql日志](C:\Users\AWU\Desktop\面试学习\o_201016234945mysql日志.png)







# 10. MylSAM 索引与lnnoDB 索引的区别？

- InnoDB 索引是聚簇索引， MyISAM 索引是非聚簇索引。
- InnoDB 的主键索引的叶子节点存储看行数据， 因此主键索引非常高效。
- MyISAM 索引的叶子节点存储的是行数据地址， 需要再寻址一次才能得到数据
- InnoDB 非主键索引的叶子节点存储的是主键和其他带索引的列数据， 因此查询时做到覆盖索引会非常高效。(不是所有类型的索引都可以成为覆盖索引。覆盖索引必须要存储索引的列，而哈希索引、空间索引和全文索引等都不存储索引列的值，所以MySQL只能使用B-Tree索引做覆盖索引)



### 覆盖索引（Covering index）

InnoDB存储引擎支持覆盖索引，即从辅助索引中就可以得到查询的记录，而不需要查询聚集索引中的记录。

使用覆盖索引有啥好处？

可以减少大量的**IO操作**
上图中我们知道，如果要查询辅助索引中不含有的字段，得**先遍历辅助索引，再遍历聚集索引**，而如**果要查询的字段值在辅助索引上就有，就不用再查聚集索引**了，这显然会减少IO操作。

 

注意：常见的IO流操作，一般说的是【内存】与【磁盘】之间的输入输出。

补充：计算机的核心部件是计算单元，即CPU，相对于CPU来说，存储（访问内存）、接口（访问外设）都是I/O。

​			对于CPU来说，如果一个指令需要从内存中读取数据，就涉及I/O操作，CPU会通过多线程、多发射（超标量）等方法在读取数据的空闲时间（这个时间还比较长）执行其他指令。



 





# 11.索引的基本原理

​		索引用来快速地寻找那些具有特定值的记录。如果**没有索引， 一般来说执行查询时遍历整张表**。 - 索引的原理很简单，就是**把无序的数据变成有序的查询** 1. 把**创建了索引的列的内容进行排序** 2. **对排序结果生成倒排表** 3. 在倒排表内容上拼上数据地址链 4. 在查询的时候， 先拿到倒排表内容， 再取出数据地址链，从而拿到具体数据







# 12.SQL 的执行顺序

1、FROM : 将数据从硬盘加载到数据缓冲区， 方便对接下来的数据进行操作．
2、WHERE : 从基表或视图中选择满足条件的元组． （不能使用聚合函数）
3、JOIN
4、ON : join on 实现多表连接查询
5 、GROUP BY : 分组
6、HAVING ．在元组的基础上进行筛选， 选出符合条件的元组。（ 一般与GROUP BY 进行连用）
7、SELECT : 查询到得所有元组需要罗列的哪些列．
8、DISTINCT : 去重的功能。
9、UNION : 将多个亘询结果台并（默认去掉重要的记录） ．
10、ORDER BY : 进行相应的排序．
11 、LIMIT 1 ： 显示输出一条数据记录（元组）





# 13. SQL 的生命周期？

1、应用服务器与数据库服务器建立一个连接
2、数据库进程拿到请求sql
3、解析并生成执行计划， 执行
4、读取数据到内存并进行逻辑处理
5、通过步骤一的连接， 发送结果到客户端
6、关掉连接， 释放资源





# 14.索引失效的几种情况

1. 有or
2. 不满足最左匹配原则
3. like ‘%xx’，即模糊查询
4. 需要类型转换
5. where中索引列有运算
6. where中索引列使用了函数
7. mysql觉得全表扫描更快的时候（数据量少）