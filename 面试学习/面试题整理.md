# 									面试题整理



## 									抽象类的意义: 对代码的**维护**和**重用**。

抽象类往往用来表征对问题领域进行分析、设计中得出的抽象概念，是对一系列看上去不同，但是本质上相同的具体概念的抽象。具体分析如下：

**1.因为抽象类不能实例化对象，所以必须要有子类来实现它之后才能使用。这样就可以把一些具有相同属性和方法的组件进行抽象，这样更有利于代码和程序的维护。**

比如本科和研究生可以抽象成学生，他们有相同的属性和方法。这样当你对其中某个类进行修改时会受到父类的限制，这样就会提醒开发人员有些东西不能进行随意修改，这样可以对比较重要的东西进行统一的限制，也算是一种保护，对维护会有很大的帮助。
**2.当又有一个具有相似的组件产生时，只需要实现该抽象类就可以获得该抽象类的那些属性和方法。**
比如学校又新产生了专科生这类学生，那么专科生直接继承学生，然后对自己特有的属性和方法进行补充即可。这样对于代码的重用也是很好的体现。

**所以，Java中抽象类对于代码的维护和重用有很好的帮助，也是Java面向对象的一个重要体现。**

------



## 												int与integer的区别

1.Integer是int的包装类，int则是java的一种基本的数据类型；

2.Integer变量必须实例化之后才能使用，而int变量不需要实例化；

3.Integer实际是对象的引用，当new一个Integer时，实际上生成一个指针指向对象，而int则直接存储数值

4.Integer的默认值是null，而int的默认值是0。

------



## 						java中==和equals和hashCode的区别



​	“==”：

　　==是运算符，用来比较两个值、两个对象的内存地址是否相等；

“equals()”：

　　equals是Object类的方法，默认情况下比较两个对象是否是同一个对象，内部实现是通过“==”来实现的。

如果想比较两个对象的其他内容，则可以通过重写equals方法，

例如：String类就重写了equals方法，改成了对象的内容是否相等。

“hashCode()”：

　　hashCoed也是Object类里面的方法，返回值是一个对象的哈希码，同一个对象哈希码一定相等，但不同对象哈希码也有可能相等。

如果两个对象通过equals方法比较相等，那么他的hashCode一定相等；

如果两个对象通过equals方法比较不相等，那么他的hashCode有可能相等；

------



## 							Java基础之接口与抽象类的区别

### 基本语法区别:Java中接口和抽象类的定义语法分别为interface与abstract关键字。



**相同点**

（1）都不能被实例化 （2）接口的实现类或抽象类的子类都只有实现了接口或抽象类中的方法后才能实例化。

**不同点**

（1）接口只有定义，不能有方法的实现，java 1.8中可以定义default方法体，而抽象类可以有定义与实现，方法可在抽象类中实现。

（2）实现接口的关键字为implements，继承抽象类的关键字为extends。一个类可以实现多个接口，但一个类只能继承一个抽象类。所以，使用接口可以间接地实现多重继承。
		补:一个抽象类的实现只能由这个抽象类的子类给出，也就是说，这个实现处在抽象类所定义出的继承的等级结构中，而由于Java语言的单继承性，所以抽象类作为类型定义工具的效能大打折扣。在这一点上，Java接口的优势就出来了，任何一个实现了一个Java接口所规定的方法的类都可以具有这个接口的类型，而一个类可以实现任意多个Java接口，从而这个类就有了多种类型。（使用抽象类，那么继承这个抽象类的子类类型就比较单一，因为子类只能单继承抽象类；而子类能够同时实现多个接口，因为类型就比较多。接口和抽象类都可以定义对象，但是只能用他们的具体实现类来进行实例化。）

（3）接口强调特定功能的实现，而抽象类强调所属关系。

（4）接口成员变量默认为public static final，必须赋初值，不能被修改；其所有的成员方法都是public、abstract的。抽象类中成员变量默认default，可在子类中被重新定义，也可被重新赋值；抽象方法被abstract修饰，不能被private、static、synchronized和native等修饰，必须以分号结尾，不带花括号。



p.s:同时使用抽象类和接口的优势

结合1、2点中抽象类和Java接口的各自优势，具精典的设计模式就出来了：声明类型的工作仍然由Java接口承担，但是同时给出一个Java 抽象类，且实现了这个接口，而其他同属于这个抽象类型的具体类可以选择实现这个Java接口，也可以选择继承这个抽象类，也就是说在层次结构中，Java 接口在最上面，然后紧跟着抽象类，这下两个的最大优点都能发挥到极至了。这个模式就是“缺省适配模式”。在Java语言API中用了这种模式，而且全都遵循一定的命名规范：Abstract ＋接口名。（A extends AbstractB implements interfaceC，那么A即可以选择实现(@Override)接口interfaceC中的方法，也可以选择不实现；A即可以选择实现(@Override)抽象类AbstractB中的方法，也可以选择不实现）



需要注意的是在抽象类中，如果方法没有具体实现（就是方法后面 **没有{}**），那么必须加上**abstract**来声明这个方法，而接口中不需要使用abstract来声明 **（抽象类之所以被称为抽象类，就是因为它包含有抽象方法。含有抽象方法的类叫做抽象类）**。



------



# 				能否创建一个包含可变对象的不可变对象?

```java
不可变对象(Immutable Object)：对象一旦被创建后，对象所有的状态及属性在其生命周期内不会发生任何变化。
```

​		可以创建一个包含可变对象的不可变对象的，你只需要谨慎一点，不要共享可变对象的引用就可以了，如果需要变化时，就返回原对象的一个拷贝。最常见的例子就是对象中包含一个日期对象的引用。



------



## 												谈谈对 java 多态的理解

多态是指**父类的某个方法被子类重写时，可以产生自己的功能行为，同一个操作 作用于不同对象，可以有不同的解释，产生不同的执行结果**。

**多态的三个必要条件**:

1. 继承父类。
2. 重写父类的方法。
3. 父类的引用指向子类对象。

#### Java多态当中父类的引用指向子类的对象的问题

如果说父类中有这个属性跟方法，子类有重写过，那么调用的是子类中的属性跟方法。
如果父类中没有这个属性跟方法，那么子类调用就会出错。
如果父类有这个属性跟方法，而子类没有，则调用的是父类的属性跟方法。



**什么是多态**:

面向对象的三大特性:**封装、继承、多态**。

从一定角度来看，封装和继承几乎都 是为多态而准备的。	

*多态的定义*:**指允许不同类的对象对同一消息做出响应。即同一消息可以根据发 送对象的不同而采用多种不同的行为方式。(发送消息就是函数调用)**

Java 中多态的实现方式:**接口实现，继承父类进行方法重写，同一个类中进行方 法重载。**



------



# 			String、StringBuffer、StringBuilder的区别与联系

（1）String是内容不可变的，而StringBuffer、StringBuilder都是内容可变的。

（2）StringBuffer是同步的，数据安全的，但是效率低；  StringBuilder是不同步的，数据不安全，相比于来说，效率高。



## 	StringBuffer和数组的区别？

二者都是可以看成是一个容器，装其他的数据，但StringBuffer的数据最终是一个字符串数据；而数组可以放置多种数据，但必须是同一种数据类型的。



补充：

String类：
字符串：就是由多个字符组成的一串数据，也可以看成是一个字符数组，通过查看API可知：

（1）字符串字面值（如：“abc”）可以看成是一个字符串对象；

（2）字符串是常量，一旦被赋值就不能被改变，这也就是为什么说：String类为什么是final的原因。

String类的特点：


A:字符串直接赋值的方式是先到字符串常量池里面去找，如果有就直接返回；如果没有，就创建并返回。

B:一旦被赋值，就不能被改变。值不能变。

在这里要永远记住一点：**“String对象一旦被创建就是固定不变的了，对String对象的任何改变都不影响到原对象，相关的任何change操作都会生成新的对象”**。

StringBuffer：
线程安全的可变字节。



# 为什么String要设计成不可变的?

***\*1. 字符串常量池的需要\****

字符串常量池(String pool, String intern pool, String保留池) 是Java堆内存中一个特殊的存储区域, 当创建一个String对象时,假如此字符串值已经存在于常量池中,则不会创建一个新的对象,而是引用已经存在的对象。

***\*2. 允许String对象缓存HashCode\****

字符串不变性保证了hash码的唯一性,因此可以放心地进行缓存.这也是一种性能优化手段,意味着不必每次都去计算新的哈希码. 在String类的定义中有如下代码:

```java
private int hash;//用来缓存HashCode
```

***\*3. 安全性\****

String被许多的Java类(库)用来当做参数,例如 网络连接地址URL,文件路径path,还有反射机制所需要的String参数等, 假若String不是固定不变的,将会引起各种安全隐患。

总体来说, String不可变的原因包括 设计考虑,效率优化问题,以及安全性这三大方面. 事实上,这也是Java面试中的许多 "为什么" 的答案。

------



## 									泛型中extends和super的区别

`<? extends T>`和`<? super T>`是Java泛型中的“通配符（Wildcards）”和“边界（Bounds）”的概念。

- <? extends T>：是指 “上界通配符（Upper Bounds Wildcards）”   上界<? extends T>不能往里存，只能往外取（一个能放水果以及一切是水果派生类的盘子。）
- <? super T>：是指 “下界通配符（Lower Bounds Wildcards）”      下界<? super T>不影响往里存，但往外取只能放在Object对象里（一个能放水果以及一切是水果基类的盘子。）



### PECS原则

最后看一下什么是PECS（Producer Extends Consumer Super）原则，已经很好理解了：

- 频繁往外读取内容的，适合用上界Extends。
- 经常往里插入的，适合用下界Super。



------



## 														进程和线程的区别

**进程是资源分配的最小单位，线程是CPU调度的最小单位**

进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位.

线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源.

**一个程序至少有一个进程,一个进程至少有一个线程.**

线程在进程下行进（单纯的车厢无法运行）

一个进程可以包含多个线程（一辆火车可以有多个车厢）

不同进程间数据很难共享（一辆火车上的乘客很难换到另外一辆火车，比如站点换乘）

同一进程下不同线程间数据很易共享（A车厢换到B车厢很容易）

进程要比线程消耗更多的计算机资源（采用多列火车相比多个车厢更耗资源）

进程间不会相互影响，一个线程挂掉将导致整个进程挂掉（一列火车不会影响到另外一列火车，但是如果一列火车上中间的一节车厢着火了，将影响到所有车厢）

进程可以拓展到多机，进程最多适合多核（不同火车可以开在多个轨道上，同一火车的车厢不能在行进的不同的轨道上）



------



# 								Java序列化的几种方式

 Java对象的序列化有两种方式。
a.是相应的对象实现了序列化接口Serializable，这个使用的比较多，对于序列化接口Serializable接口是一个空的接口，它的主要作用就是          标识这个对象时可序列化的，jre对象在传输对象的时候会进行相关的封装。

b.实现序列化的第二种方式为实现接口Externalizable



- **序列化：将对象写入到IO流中**
- **反序列化：从IO流中恢复对象**
- **意义：序列化机制允许将实现序列化的Java对象转换位字节序列，这些字节序列可以保存在磁盘上，或通过网络传输，以达到以后恢复成原来的对象。序列化机制使得对象可以脱离程序的运行而独立存在。**



**序列化步骤：**

- **步骤一：创建一个ObjectOutputStream输出流；**

- **步骤二：调用ObjectOutputStream对象的writeObject输出可序列化对象。**

  

**反序列化步骤：**

- **步骤一：创建一个ObjectInputStream输入流；**
- **步骤二：调用ObjectInputStream对象的readObject()得到序列化的对象。**



------

# 	静态属性和静态方法是否可以被继承？是否可以被重写？以及原因？

**父类的静态属性和方法可以被子类继承**

不可以被子类重写：当父类的引用指向子类时，使用对象调用静态方法或者静态变量，是调用的父类中的方法或者变量。并没有被子类改写。 

原因：

因为静态方法从程序开始运行后就已经分配了内存，也就是说已经写死了。所有引用到该方法的对象（父类的对象也好子类的对象也好）所指向的都是同一块内存中的数据，也就是该静态方法。

子类中如果定义了相同名称的静态方法，并不会重写，而应该是在内存中又分配了一块给子类的静态方法，没有重写这一说。

------



# 成员内部类、静态内部类、局部内部类和匿名内部类的理解，以及项目中的应用

### ***\*成员内部类\****

定义在类内部的非静态类，就是成员内部类。

### ***\*静态内部类：\****

定义在类内部的静态类，就是静态内部类。

### ***\*局部内部类\****

定义在方法中的类，就是局部类。（局部内部类是嵌套在方法和作用于内的，对于这个类的使用主要是应用与解决比较复杂的问题，想创建一个类来辅助我们的解决方案，到那时又不希望这个类是公共可用的，所以就产生了局部内部类，局部内部类和成员内部类一样被编译，只是它的作用域发生了改变，它只能在该方法和属性中被使用，出了该方法和属性就会失效。）***\*匿名内部类\****

匿名内部类是没有访问修饰符的。

1. new 匿名内部类，这个类首先是要存在的。
2. 当所在方法的形参需要被匿名内部类使用，那么这个形参就必须为final。
3. 匿名内部类没有明面上的构造方法，编译器会自动生成一个引用外部类的构造方法。

常用的绑定监听就是匿名内部类的一个范例。

------



## 														Java的异常体系

 Java把异常作为一种类，当做对象来处理。所有异常类的基类是Throwable类，两大子类分别是Error和Exception。

　　异常（Exception）又分为RuntimeException(运行时异常)和CheckedException(检查时异常)，两者区别如下：

- RuntimeException：程序运行过程中才可能发生的异常。一般为代码的逻辑错误。例如：类型错误转换，数组下标访问越界，空指针异常、找不到指定类等等。
- CheckedException：编译期间可以检查到的异常，必须显式的进行处理（捕获或者抛出到上一层）。例如：IOException, FileNotFoundException等等。



## 异常的处理

　　**常用关键字：try、catch、throw（抛出一个异常，动词）、throws（声明一个方法可能抛出的异常）\**、\**finally**



### 什么是异常链

 异常链是为了解决某种特别的情况：A 方法调用B 方法时，B 方法却抛出了异常。那么A 方法是继续抛出原有的异常还是抛出一个新异常呢？我们可以具体的分析便可以了解异常链的用处了。

   首先，是抛出原有的异常。这就很糟糕的设计方法。这样A 方法与B 方法进行了关联，这样不便于代码的修改和扩展。其次，抛出新的异常。虽然它解决了A 方法和B 方法的关联问题 ，但是原有的异常信息却丢失了。那么异常链的出现正是解决这个问题。它虽然创建了新的异常但却保留了原有异常的信息。

   Throwable 根异常类通过其属性cause 来保存原有的异常信息。该属性可以通过构造方法，如果该异常类实现带Throwable 的构造器，还可以通过initCause（）方法来赋值。

现在所有Throwable的子类子构造器中都可以接受一个cause对象作为参数，这个cause就异常原由，代表着原始异常，即使在当前位置创建并抛出行的异常，也可以通过这个cause追踪到异常最初发生的位置。

   注意：如果cause 指向自己说明该属性没有初始化或该异常就是异常的源头。

------

## 											

## 												throw和throws的区别

 throw语句用在方法体内，表示抛出异常，由方法体内的语句处理。
       throw是具体向外抛异常的动作，所以它是抛出一个异常实例。
       throws语句用在方法声明后面，表示再抛出异常，由该方法的调用者来处理。
       throws主要是声明这个方法会抛出这种类型的异常，使它的调用者知道要捕获这个异常。



------

## 				

## 			反射的原理，反射创建类实例的三种方式是什么。 谈谈你对Java反射的理解

反射机制就是在程序的运行过程中被允许对程序本身进行操作，比如自我检查，进行装载，还可以获取类本身，类的所有成员变量和方法，类的对象，还可以在运行过程中动态的创建类的实例，通过实例来调用类的方法

**反射机制：**Java反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为Java语言的反射机制。

通过反射我们可以直接操作类和对象，比如获取某个类的定义，获取类的属性和方法，构造方法等。

创建类实例的三种方式是

- 对象实例.getClass()；
- 通过 Class.forName() 创建
- 对象实例.newInstance() 方法创建



**java反射机制有三个动态特性：**

（1）运行时生成对象实例。

（2）运行时调用方法.

（3）运行时更改属性。

------



## 													java当中的四种引用

 强引用，软引用，弱引用，虚引用

1. 强引用

 是指创建一个对象并把这个对象赋给一个引用变量。

比如：

```java
Object object =``new` `Object();
```

 强引用有引用变量指向时永远不会被垃圾回收，JVM宁愿抛出OutOfMemory错误也不会回收这种对象。



2. 软引用（SoftReference）

如果一个对象具有软引用，内存空间足够，垃圾回收器就不会回收它；

如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。

软引用可用来实现内存敏感的高速缓存,比如网页缓存、图片缓存等。使用软引用能防止内存泄露，增强程序的健壮性。  
SoftReference的特点是它的一个实例保存对一个Java对象的软引用， 该软引用的存在不妨碍垃圾收集线程对该Java对象的回收。



3. 弱引用（WeakReference）

　　弱引用也是用来描述非必需对象的，当JVM进行垃圾回收(调用System.gc方法)时，无论内存是否充足，都会回收被弱引用关联的对象。



4. 虚引用（PhantomReference）

　　虚引用和前面的软引用、弱引用不同，它并不影响对象的生命周期。在java中用java.lang.ref.PhantomReference类表示。如果一个对象与虚引用关联，则跟没有引用与之关联一样，在任何时候都可能被垃圾回收器回收。

　　要注意的是，虚引用必须和引用队列关联使用，当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会把这个虚引用加入到与之 关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。



------



# 								浅拷贝和深拷贝的区别？

1、浅拷贝：对基本数据类型进行值传递，对引用数据类型进行引用传递般的拷贝，此为浅拷贝。

2、深拷贝：对基本数据类型进行值传递，对引用数据类型，创建一个新的对象，并复制其内容，此为深拷贝。



### Object 上的 clone() 方法

在 Java 中，所有的 Class 都继承自 Object ，而在 Object 上，存在一个 clone() 方法，它被声明为了 `protected` ，所以我们可以在其子类中，使用它。

而无论是浅拷贝还是深拷贝，都需要实现 clone() 方法，来完成操作。



那么，如何进行一个**深拷贝**呢？

比较常用的方案有两种：

1. 序列化（serialization）这个对象，再反序列化回来，就可以得到这个新的对象，无非就是序列化的规则需要我们自己来写。
2. 继续利用 clone() 方法，既然 clone() 方法，是我们来重写的，实际上我们可以对其内的引用类型的变量，再进行一次 clone()。

------



# 			Java 中的编译期常量是什么?使用它有什么风险?

1. 编译期常量指的就是程序在编译时就能确定这个常量的具体值

2. 非编译期常量就是程序在运行时才能确定常量的值，因此也称为运行时常量

3. 定义上来说，声明为final类型的基本类型或String类型并直接赋值（非运算）的变量就是编译期常量，即：

   ```java
   //编译时常量
   final int i = 4;
   final String str = "dasd";
   
   // 非编译期常量
   final String str1 = new String("dasd");
   
   
   Random rand = new Random(47);
   //这个也是非编译期常量,为运行时常量
   final int i4 = rand.nextInt(20);
   ```

   

   ​		这种方式存在的一个问题是你使用了一个内部的或第三方库中的公有编译时常量，但是这个值后面被其他人改变了，部署了一个新的jar,但是你的客户端仍然在使用老的值。为了避免这种情况，当你在更新依赖 JAR 文件时，确保重新编译你的程序。这里的更新JAR文件，重新编译程序是为了更新你使用的编译期常量的值！



------

## 									String对象的intern()熟悉么?

intern()方法会首先从常量池中查找是否存在该常量值，如果常量池中不存在则现在常量池中创建，如果已经存在则直接返回。





------



# 						a=a+b和a+=b有什么不同

性能方面
　　a=a+b是加法运算 需要两次寻找地址而a+=b是增量运算有寄存器优先时 只有一次地址查找。效率方面后者略高于前者 基于现在计算机的发展可忽略不计。

可读性方面
　　两者都是赋值运算，一般情况下可以认为两者没有什么区别 但前者与数学算法描述更接近相对来说更严谨而后者书写更快捷但可读性下降。

数据类型方面
　　两者写法上主要在于是否能进行数据类型自动转换，事实上就是类型与精度上的差异。eg:当两个操作数 数据类型一致时两种形式的运算结果没有差别 但数据类型不同时 且a值的数据类型精度低时 此时两种形式就有区别了。



在两个变量的数据类型一样时：a+=b 和a=a+b 是没有区别的。

但是当两个变量的数据类型不同时，就需要考虑一下数据类型自动转换的问题了。

------



# 			面试题-静态代理和动态代理的区别，什么场景使用？

代理模式（Proxy Pattern），又叫委托模式，是指为其他对象提供一种代理，以控制对这个对象的访问，属于结构型设计模式
目的是为了保护目标对象或增强目标对象



# 静态代理

显示声明代理对象，在编译期就生成了代理类
由程序员创建或特定工具自动生成源代码，再对其编译。在程序运行之前，代理类的类文件就已经被创建了



动态代理
在程序运行时通过反射机制动态创建代理类
优点：只需将被委托类作为参数传入即可，使用灵活；服务内容只需写在invoke方法中，减少了代码冗余
缺点：效率较低

基于JDK实现：通过JDK提供的工具方法Proxy.newProxyInstance动态构建全新的代理类（继承Proxy类，并持有InvocationHandler接口引用）字节码文件并实例化对象返回。由Java内部的反射机制来实例化代理对象，并代理的调用委托类方法

基于CGlib实现：基于继承被代理类生成代理子类，不用实现接口，只需被代理类为非final类，底层借用ASM字节码技术实现

基于AspectJ实现：修改目标类的字节，织入代理的字节，在程序编译的时候，插入动态代理的字节码，不会生成全新的class

------



## 										Java中实现多态的机制是什么？

靠的是父类或接口的引用指向子类或实现类的对象，

调用的方法是内存中正在运行的那个对象的方法。

Java中的多态靠的是父类或接口定义的引用变量可以指向子类或具体实现类的实例对象，而程序调用的方法在运行期才动态绑定，就是引用变量所指向的具体实例对象的方法，也就是内存里正在运行的那个对象的方法，而不是引用变量的类型中定义的方法。



------



## 								如何将一个Java对象序列化到文件里？

在java中能被序列化的类必须实现Serializable接口,该接口没有任何抽象方法只是起到一个标记作用.

```java
ObjectOutputStream objectOutputStream=new ObjectOutputStream(new FileOutputStream("D://obj"));
        objectOutputStream.writeObject(qDingVo );
        objectOutputStream.close();
        //对象输入流
        ObjectInputStream objectInputStream=new ObjectInputStream(new FileInputStream(new File("D://obj")));
        QDingVo tempQDingVo= (QDingVo) objectInputStream.readObject();
        System.out.println("tempQDingVo:"+tempQDingVo);
        objectInputStream.close();

```



------



## 										说说你对Java注解的理解

注解，也叫元数据。可以声明在包、类、字段、方法、局部变量、方法参数等前面，来对这些元素进行说明，注释等。

***\*元注解：\****

java提供了四个元注解，所谓元注解就是负责注解其他注解。

***\*1.@Target ：\****规定注解所修饰的对象范围。

 ElementType.CONSTRUCTIR; 构造器声明
ElementType.FIELD; 成员变量，对象，属性（包括enum实例）
ElementType.LOCAL_VARIABLE; 局部变量声明
ElementType.METHOD ; 方法声明
ElementType.PACKAGE; 包声明
ElementType.PARAMETER;参数声明
ElementType.TYPE; 类、接口（包括注解类型）或enum声明

**2.@Retention ：** 表示注解的生命周期

RetentionPolicy.SOUREC: 在源文件中有效
RetentionPolicy.CLASS; 在class文件中有效
RetentionPolicy.RUNTIME;在运行时有效

**3.@Inherited :** 标记注解，主要说明了一种继承性，意思是子类可以继承父类中的该注解（注意：只有当被贴上@Inherited标签的注解被用在类上的时候子类才能获得这个注解）。 

**4.@Documented ：** 用于描述其它类型的annotation（注解）应该被作为被标注的程序成员的公共API,因此可以被例如javadoc此类的工具文档化。（表明这个注释是由 javadoc记录的，在默认情况下也有类似的记录工具。 如果一个类型声明被注释了文档化，它的注释成为公共API的一部分。）

------



## 								说一下泛型原理，并举例说明

Java泛型的实现方法：类型擦除

Java的泛型是伪泛型。在编译期间，所有的泛型信息都会被擦除掉。

***\*类型擦除（type erasure）\*******\*：\****

Java中的泛型基本上都是在编译器这个层次来实现的。在生成的Java字节码中是不包含泛型中的类型信息的。使用泛型的时候加上的类型参数，会在编译器在编译的时候去掉。这个过程就称为类型擦除。

------





------



# 												集合

## 								Collection 和Collections 的区别？

Collection是java.util下的接口，它是各种集合的父接口，继承它的主要有Set和List；
Collections是java.util下的类，是针对集合的帮助类，提供一系列静态方法实现对各种集合的搜索、排序、线程安全化等操作。

------

 

## 												什么是集合

集合框架：用于存储数据的容器。

集合框架是为表示和操作集合而规定的一种统一的标准的体系结构。
任何集合框架都包含三大块内容：对外的接口、接口的实现和对集合运算的算法。

接口：表示集合的抽象数据类型。接口允许我们操作集合时不必关注具体实现，从而达到“多态”。在面向对象编程语言中，接口通常用来形成规范。

实现：集合接口的具体实现，是重用性很高的数据结构。

算法：在一个实现了某个集合框架中的接口的对象身上完成某种有用的计算的方法，例如查找、排序等。这些算法通常是多态的，因为相同的方法可以在同一个接口被多个类实现时有不同的表现。事实上，算法是可复用的函数。
它减少了程序设计的辛劳。

集合框架通过提供有用的数据结构和算法使你能集中注意力于你的程序的重要部分上，而不是为了让程序能正常运转而将注意力于低层设计上。
通过这些在无关API之间的简易的互用性，使你免除了为改编对象或转换代码以便联合这些API而去写大量的代码。 它提高了程序速度和质量。

------





































