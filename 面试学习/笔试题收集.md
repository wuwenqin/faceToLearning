# 									笔试问题收集处

 

## Java基础类：

#### (1)  下面描述中，符合结构化程序设计风格的是(A)

A.使用顺序、选择、重复(循环) 3种基本控制结构表示程序的控制逻辑

B. 模块只有一个入口。可以有多个出口

C. 注重提高程序的执行效率

D. 不适用 goto 语句

解析：符合结构化程序设计风格中，应该选择只有一个入口和一个出口的模块。B错误

​			首先要保证程序正确，然后才要求提高效率，C错误。

​			严格控制使用 goto 语句，必要时可以使用。



------



## 数据结构与算法：

#### (1) 单链表节点的数据元素只能是哪一种?  ( C )

A. 整型        B.字符串          C. 任何数据类型         D. 实型

分析：单链表是一种**链式存取**的数据结构，用**一组地址任意的存储单元**存放线性表中的数据元素。**每个结点的构成：元素（数据元素**的映象) + 指针（**指示后继元素存储位置) ，其数据元素没有特定的类型限制**。

![](C:\Users\AWU\Desktop\面试学习\笔试题整理图片存储处\单链表数据结构.jpg)















------



## 多线程：

#### (1)下列方法中，可以用来创建一个新线程的是（ BC）

A.实现 java.lang.Runnable 接口并重写 start()方法

B. 实现 java.lang.Runnable 接口并重写 run() 方法

C. 继承 java.lang.Thread 类 并重写 run() 方法

D. 继承 java.lang.Thread 类 并重写 start() 方法

分析：继承java.lang.Thread 类或直接实现 Runnable 接口 并重写 run()方法实现线程。

创建线程的三种方法：

① 继承Thread类，重写run() 方法，run方法代表线程要执行的任务

② 实现Runnable 接口，重写 run() 方法，run方法代表线程要执行的任务

③ 实现 Callable 接口，重写 call() 方法，call() 方法作为线程的执行体，具有返回值，并且可以对异常进行声明和抛出。



#### (2) 在run方法结束前消灭线程的方法：

① 使用退出标志 终止线程。当run方法执行完后，线程就会退出，也就是当run方法完成后线程终止。

② 使用stop方法强行终止线程。（不建议使用）

③ 使用 interrupt 方法中断线程。该方法来终止线程可分为两种情况：一是线程处于阻塞状态，如使用了sleep方法。二是使用while来判断线程是否被中断。

对应的，在第一种情况下使用interrupt方法，sleep方法会抛出一个InterruptedException异常，而第二种情况下线程将直接退出。



#### (3 )  线程有哪几种状态：

5种，分别是   **新建、就绪、运行、阻塞、终止状态**。

①新建(new )： 用**new语句**创建的线程处于**新建状态**。此时它和其他的Java对象一样，仅仅在堆（heap）中被分配了内存，当一个线程处于新建状态时，它仅仅是一个空的线程对象，系统不为他分配资源。 如  Thread t=new Thread(new Runner());

② 就绪（Runnable）： 程序通过线程对象调用启动方法start()方法后，系统会为这个线程分配它运行时所需的处理器之外的所有系统资源。这时它处于随时可以运行的状态，只要获得处理器即会进入运行态中。 如 t.start();

③ 运行（Running）： 处于这个状态的线程占用CPU，执行程序代码。在并发环境中，如果计算机只有一个CPU，那么任何时刻只有一个线程处于运行态。如果计算机中有多个CPU，那么同一时刻可以让多个线程占用不同的CPU一同运行。且只有处于 就绪状态的线程才能转到运行态中。

④ 阻塞（Blocked）：阻塞状态是指线程因为某些原因放弃CPU的占用，暂时停止运行，当线程处于阻塞状态时，Java虚拟机不会给线程分配CPU，直到线程重新进入就绪状态，才能有机会转到运行态中。

阻塞状态可以分为以下三种：一是  位于对象等待池中的阻塞状态——当线程处于运行状态时，如果执行了某个对象的wait()方法，Java虚拟机就会把该线程放到对象等待池中。

二是位于对象锁池中的阻塞状态——当线程处于运行状态，试图获得某个对象的同步锁时，如果该对象的同步锁已经被其他线程占用，Java虚拟机就会把该线程放入这个对象的锁池中。

三是其他阻塞状态：当前线程执行了sleep() 方法，或调用了其他线程的 join() 方法，或者发出了I/O请求，该线程放弃CPU，进入阻塞状态，直到I/O处理完毕，该线程才会恢复执行。

⑤ 终止状态（Dead）：当线程退出run()方法时，就进入终止状态，该线程结束生命周期，。线程有可能是正常执行完程序后而退出，也可能是 遇到异常 而退出。



------



## IO流：

#### (1) 以下（ C ）方法可以实现与指定的URL建立连接并返回Input Stream类的对象，以从这一连接中读取数据。

A.readLine()   B. read()  C. openStream()   D. new URL()



注：read() 方法 把字节读取成字符，按字符进行读取输出流；

​		readLine() 方法 按行读取，直至读到空格或者换行符停止。



分析：如何建立URL连接？ URL和URLConnection类封装了大量复杂的实现细节，这些细节设计如何从远程站点获取信息。  有如下方法：

① 通过传递字符串来构建 URL对象  

```java
URL url=new URL(urlString);
```



② 通过openStream()方法获取链接地址的内容。该方法返回一个 InputStream 对象。

```java
//通过URL构建Scanner对象
InputStream inStream =url.openStream();
Scanner in=new Scanner(inStream);
```













------



## Linux 系统：

#### (1) 有一个脚本 showenv，需要设置成只有文件所有者(自己) 可以运行，其他任何账户都不能运行，你需要运行命令( D )

A. chmod u+x showenv

B. chomd g+x showenv

C. chmod o+x showenv

D. 以上命令均不能实现



分析：chmod 命令中， u: 表示文件所有者；  +: 添加某个权限;   x: 可执行

首先，chmod命令用于改变linux系统文件或目录的访问权限。该命令的用法有两种：

 第一种，包含字母和操作符表达式的文字设定法；第二种，包含数字的数字设定法；



**权限范围**：**u： 目录或文件的所有者；    g: 目录或文件所属群组；**  

​		**o：除了目录或文件的当前用户或群组之外的用户或群组； a:所有的用户及群组**

**权限代号**：   

​		**r：读权限，用数字4表示 ；     w： 写权限，用数字2表示；**

​		**x：执行权限，用数字1表示；  -：删除权限，用数字0表示；**

​		**s：特殊权限**

命令使用例子： 

  (1) chmod **a+x** 文件名  ： **增加文件所有用户组可执行权限**

  (2) chmod ug+w,o-x 文件名： **同时修改不同用户权限**。本条命令的含义为：设定文件所有者增加写权限；与文件属主同组用户增加写权限；其他用户(o) 删除执行权限。

  (3) chmod a-x 文件名： **删除文件权限**。本条命令含义为：删除所有用户的可执行权限。

  (4) chmod u=r 文件名： **使用 “=” 设置权限**。本条命令含义为：撤销原来所有的权限，然后使拥有者具有可读权限。

  (5) chmod -R u+x 文件名： **对一个目录及其子目录的所有文件添加权限**。这里需要注意：-R 起到递归的作用，及Recursive。本条命令为：递归地给指定目录下的所有文件及其子目录的属主分配权限。   



数字使用法：

（1） chmod 751 文件名：等价于 chmod u=rwx,g=rx,o=x 文件名。

​		本条命令含义为：给文件的所有者分配读、写、执行(4+2+1=7)的权限，给file的所在组分配读、执行(4+1=5)的权限，给其他用户分配执行(1)的权限。

(2) 其他用法：   **chmod =r 文件名**

等价于  chmod u=r,g=r,o=r 文件名  或 chmod 444 文件名； 

含义为：为所有用户分配**读权限**。



------

## 操作系统：

### (1)  我们把在一段时间内，只允许一个进程访问的资源，称为临界资源。因此，我们可以得出下列论述，正确的是（B）

A. 对临界资源 是不能实现资源共享的。

B. 对临界资源，应采取互斥访问方式，来实现共享。

C. 为临界资源配上相应的设备控制块后，便能被共享。

D. 对临界资源应采取同时访问方式，来实现共享。



分析：临界资源是指 被多个线程共享的资源，需要互斥访问。

补充说明：这里的知识需要了解  临界资源、信号量等方式。











------

## 计算机网络：

### (1) 以下对TCP和UDP描述正确的是：（D F）

A. TCP 不能提供数据传输的可靠性

B. UDP能够保证数据传输的可靠性

C. TCP数据传输效率高于UDP

D. TCP是面向连接的，UDP不是面向连接的

E. TCP运行在IP层之上，UDP 不一定运行在IP层之上

F. TCP和UDP程序在同一机器上可以使用相同的接口



分析：由于TCP是面向连接的，所以可以提供数据传输的可靠性，故A错误。

​			且UDP是面向无连接的，提供尽最大努力交付的连接（不可靠），故B错误。

​			TCP报文的首部是20字节，而UDP首部是8个字节，故UDP传输效率更高。故C错误

​			TCP不一定运行在IP层之上，通用路由封装( GRE) 定义了在任意一种网络层协议上封装任意一个其他网络层协议的协议。故E错误。

​			不同的协议可以使用相同的接口，所以TCP和UDP传输协议监听同一个端口后，接收数据互不影响、不冲突。这是由于  数据接收时根据  五元组{ 传输协议，源IP，目的IP，源端口，目的端口} （或者简化为三元组{ 协议，ip,端口号} ）来判断接收者的，F正确。

​			









------



## J2EE知识：JSP基础

#### (1) 在 J2EE 中，以下不是jsp隐式对象的是（ B）

A. PageContext   B. context   C. application  D. out

分析： jsp的九大隐式对象分别是  request，response，out，session，application，pageContext，page，config，exception。



#### (2) Servlet中，HTTPServletResponse 的（ C）方法用来把一个HTTP请求重定向到另外的URL。

A.sendURL()  B.redirectURL()  C. sendRedirect()  D.redirectResponse()



#### (3 )  WEB应用中，典型的4种会话跟踪方法：

使用Cookie， URL重写，隐藏表单域，session。



分析：

①Cookie是当用户浏览某网站时，由Web服务器置于硬盘上的一个非常小的文本文件，它可以记录客户的用户ID、密码、浏览过的网页、停留的时间等信息。当用户再次来到该网站时，网站通过读取Cookie，得知用户的相关信息，就可以做出响应。如：无需再次输入账号和密码即可直接登录；在页面显示欢迎标语等。

但Cookie只有在用户允许其浏览器支持Cookie时才可以实现会话跟踪功能。



② URL重写：在HTTP中，GET方法可以实现数据由客户端到服务器端的传送，URL重写是利用了GET函数，在URL尾部添加了一些额外的参数来实现会话跟踪。

在一些实际应用中，需要为每个用户指定一个唯一的标识，为了把会话ID正确的嵌入到发送给用户的URL中，可以调用 HttpServletResponse.encodeURL() 方法将 URL转换成正确的字符串。



**该会话跟踪方法的缺点**：必须对指向本Web站点的URL进行编码，所有页面都必须动态生成。

不能使用预先记录下来的URL进行访问，或者从其他网站链接进行访问

用户ID和登陆密码等重要信息可能以参数的形式暴露在URL上，造成安全隐患。

大部分的URL的长度有限制，不能传送大量的数据。



③ 隐藏的表单域：隐藏表单域是利用HTML中的隐藏域，在网页表单内隐藏某些客户端的信息。这些信息会随着客户端的请求信息一起传送给服务器，服务器通过获取的这些信息进行会话跟踪。

​	隐藏域的HTML标签如下：  <input type ="hidden" name="隐藏域名称" value="默认值" >

这些识别信息是隐藏的，所以不会在客户端的浏览器页面上显示，但是，如果查看HTML的源文件，是可以看到这些隐藏字段的。故这也可能会导致用户资料的泄露。









------

## MYSQL：

(1) 使用 CREATEW VIEW  创建视图时，如果给定了（ B ）子句，能替换已有的视图。

A. ALL REPLACE   B. OR REPLACE   C. REPLACE  D.  REPLACE ALL



(2) 语句ALTER TABLE  实现的是哪类功能：（ C）

A. 数据查询    B. 数据操纵  C. 数据定义  D. 数据控制











